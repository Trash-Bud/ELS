/*
 * generated by Xtext 2.32.0
 */
package pt.up.fe.els2023.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import pt.up.fe.els2023.dsl.AddColumnTransformation;
import pt.up.fe.els2023.dsl.AppendPathTransformation;
import pt.up.fe.els2023.dsl.Assignment;
import pt.up.fe.els2023.dsl.AutoType;
import pt.up.fe.els2023.dsl.CanonicalizePathTransformation;
import pt.up.fe.els2023.dsl.CombinationOperations;
import pt.up.fe.els2023.dsl.CsvType;
import pt.up.fe.els2023.dsl.DslPackage;
import pt.up.fe.els2023.dsl.Export;
import pt.up.fe.els2023.dsl.FoldAverageTranformation;
import pt.up.fe.els2023.dsl.FoldSumTranformation;
import pt.up.fe.els2023.dsl.FoldTransformation;
import pt.up.fe.els2023.dsl.GetPathTransformation;
import pt.up.fe.els2023.dsl.GroupBy;
import pt.up.fe.els2023.dsl.HtmlType;
import pt.up.fe.els2023.dsl.InlinePipeline;
import pt.up.fe.els2023.dsl.InlineSource;
import pt.up.fe.els2023.dsl.JsonType;
import pt.up.fe.els2023.dsl.MetaData;
import pt.up.fe.els2023.dsl.MyDsl;
import pt.up.fe.els2023.dsl.OutputType;
import pt.up.fe.els2023.dsl.PathTransformation;
import pt.up.fe.els2023.dsl.Pipeline;
import pt.up.fe.els2023.dsl.PipelineTableOperation;
import pt.up.fe.els2023.dsl.RemoveColumnTransformation;
import pt.up.fe.els2023.dsl.RenameColumnTransformation;
import pt.up.fe.els2023.dsl.RoundCellsTransformation;
import pt.up.fe.els2023.dsl.SelectColumnTransformation;
import pt.up.fe.els2023.dsl.SelectPipeline;
import pt.up.fe.els2023.dsl.SelectRowsTransformation;
import pt.up.fe.els2023.dsl.SelectSource;
import pt.up.fe.els2023.dsl.SetCellsTransformation;
import pt.up.fe.els2023.dsl.SortRowsTransformation;
import pt.up.fe.els2023.dsl.Source;
import pt.up.fe.els2023.dsl.SourceCoumnSelect;
import pt.up.fe.els2023.dsl.SourceOperation;
import pt.up.fe.els2023.dsl.SourceStore;
import pt.up.fe.els2023.dsl.Table;
import pt.up.fe.els2023.dsl.TableOperations;
import pt.up.fe.els2023.dsl.TransformOperation;
import pt.up.fe.els2023.dsl.TransformationTableOperation;
import pt.up.fe.els2023.dsl.XmlType;
import pt.up.fe.els2023.dsl.YamlType;
import pt.up.fe.els2023.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ADD_COLUMN_TRANSFORMATION:
				sequence_AddColumnTransformation(context, (AddColumnTransformation) semanticObject); 
				return; 
			case DslPackage.APPEND_PATH_TRANSFORMATION:
				sequence_AppendPathTransformation(context, (AppendPathTransformation) semanticObject); 
				return; 
			case DslPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case DslPackage.AUTO_TYPE:
				sequence_AutoType(context, (AutoType) semanticObject); 
				return; 
			case DslPackage.CANONICALIZE_PATH_TRANSFORMATION:
				sequence_CanonicalizePathTransformation(context, (CanonicalizePathTransformation) semanticObject); 
				return; 
			case DslPackage.COMBINATION_OPERATIONS:
				sequence_CombinationOperations(context, (CombinationOperations) semanticObject); 
				return; 
			case DslPackage.CSV_TYPE:
				sequence_CsvType(context, (CsvType) semanticObject); 
				return; 
			case DslPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case DslPackage.FOLD_AVERAGE_TRANFORMATION:
				sequence_FoldAverageTranformation(context, (FoldAverageTranformation) semanticObject); 
				return; 
			case DslPackage.FOLD_SUM_TRANFORMATION:
				sequence_FoldSumTranformation(context, (FoldSumTranformation) semanticObject); 
				return; 
			case DslPackage.FOLD_TRANSFORMATION:
				sequence_FoldTransformation(context, (FoldTransformation) semanticObject); 
				return; 
			case DslPackage.GET_PATH_TRANSFORMATION:
				sequence_GetPathTransformation(context, (GetPathTransformation) semanticObject); 
				return; 
			case DslPackage.GROUP_BY:
				sequence_GroupBy(context, (GroupBy) semanticObject); 
				return; 
			case DslPackage.HTML_TYPE:
				sequence_HtmlType(context, (HtmlType) semanticObject); 
				return; 
			case DslPackage.INLINE_PIPELINE:
				sequence_InlinePipeline(context, (InlinePipeline) semanticObject); 
				return; 
			case DslPackage.INLINE_SOURCE:
				sequence_InlineSource(context, (InlineSource) semanticObject); 
				return; 
			case DslPackage.JSON_TYPE:
				sequence_JsonType(context, (JsonType) semanticObject); 
				return; 
			case DslPackage.META_DATA:
				sequence_MetaData(context, (MetaData) semanticObject); 
				return; 
			case DslPackage.MY_DSL:
				sequence_MyDsl(context, (MyDsl) semanticObject); 
				return; 
			case DslPackage.OUTPUT_TYPE:
				sequence_OutputType(context, (OutputType) semanticObject); 
				return; 
			case DslPackage.PATH_TRANSFORMATION:
				sequence_PathTransformation(context, (PathTransformation) semanticObject); 
				return; 
			case DslPackage.PIPELINE:
				sequence_Pipeline(context, (Pipeline) semanticObject); 
				return; 
			case DslPackage.PIPELINE_TABLE_OPERATION:
				sequence_PipelineTableOperation(context, (PipelineTableOperation) semanticObject); 
				return; 
			case DslPackage.REMOVE_COLUMN_TRANSFORMATION:
				sequence_RemoveColumnTransformation(context, (RemoveColumnTransformation) semanticObject); 
				return; 
			case DslPackage.RENAME_COLUMN_TRANSFORMATION:
				sequence_RenameColumnTransformation(context, (RenameColumnTransformation) semanticObject); 
				return; 
			case DslPackage.ROUND_CELLS_TRANSFORMATION:
				sequence_RoundCellsTransformation(context, (RoundCellsTransformation) semanticObject); 
				return; 
			case DslPackage.SELECT_COLUMN_TRANSFORMATION:
				sequence_SelectColumnTransformation(context, (SelectColumnTransformation) semanticObject); 
				return; 
			case DslPackage.SELECT_PIPELINE:
				sequence_SelectPipeline(context, (SelectPipeline) semanticObject); 
				return; 
			case DslPackage.SELECT_ROWS_TRANSFORMATION:
				sequence_SelectRowsTransformation(context, (SelectRowsTransformation) semanticObject); 
				return; 
			case DslPackage.SELECT_SOURCE:
				sequence_SelectSource(context, (SelectSource) semanticObject); 
				return; 
			case DslPackage.SET_CELLS_TRANSFORMATION:
				sequence_SetCellsTransformation(context, (SetCellsTransformation) semanticObject); 
				return; 
			case DslPackage.SORT_ROWS_TRANSFORMATION:
				sequence_SortRowsTransformation(context, (SortRowsTransformation) semanticObject); 
				return; 
			case DslPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case DslPackage.SOURCE_COUMN_SELECT:
				sequence_SourceCoumnSelect(context, (SourceCoumnSelect) semanticObject); 
				return; 
			case DslPackage.SOURCE_OPERATION:
				sequence_SourceOperation(context, (SourceOperation) semanticObject); 
				return; 
			case DslPackage.SOURCE_STORE:
				sequence_SourceStore(context, (SourceStore) semanticObject); 
				return; 
			case DslPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case DslPackage.TABLE_OPERATIONS:
				sequence_TableOperations(context, (TableOperations) semanticObject); 
				return; 
			case DslPackage.TRANSFORM_OPERATION:
				sequence_TransformOperation(context, (TransformOperation) semanticObject); 
				return; 
			case DslPackage.TRANSFORMATION_TABLE_OPERATION:
				sequence_TransformationTableOperation(context, (TransformationTableOperation) semanticObject); 
				return; 
			case DslPackage.XML_TYPE:
				sequence_XmlType(context, (XmlType) semanticObject); 
				return; 
			case DslPackage.YAML_TYPE:
				sequence_YamlType(context, (YamlType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddColumnTransformation returns AddColumnTransformation
	 *     ColumnTransformation returns AddColumnTransformation
	 *     Transformation returns AddColumnTransformation
	 *
	 * Constraint:
	 *     (column=STRING value=STRING)
	 * </pre>
	 */
	protected void sequence_AddColumnTransformation(ISerializationContext context, AddColumnTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ADD_COLUMN_TRANSFORMATION__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ADD_COLUMN_TRANSFORMATION__COLUMN));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ADD_COLUMN_TRANSFORMATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ADD_COLUMN_TRANSFORMATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddColumnTransformationAccess().getColumnSTRINGTerminalRuleCall_1_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getAddColumnTransformationAccess().getValueSTRINGTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AppendPathTransformation returns AppendPathTransformation
	 *
	 * Constraint:
	 *     path=STRING
	 * </pre>
	 */
	protected void sequence_AppendPathTransformation(ISerializationContext context, AppendPathTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.APPEND_PATH_TRANSFORMATION__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.APPEND_PATH_TRANSFORMATION__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppendPathTransformationAccess().getPathSTRINGTerminalRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (name=ID (expression=Pipeline | expression=Source | expression=Table))
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AutoType returns AutoType
	 *     InputType returns AutoType
	 *
	 * Constraint:
	 *     {AutoType}
	 * </pre>
	 */
	protected void sequence_AutoType(ISerializationContext context, AutoType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CanonicalizePathTransformation returns CanonicalizePathTransformation
	 *
	 * Constraint:
	 *     {CanonicalizePathTransformation}
	 * </pre>
	 */
	protected void sequence_CanonicalizePathTransformation(ISerializationContext context, CanonicalizePathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CombinationOperations returns CombinationOperations
	 *
	 * Constraint:
	 *     ((operation='merge' | operation='append') (type='union' | type='intersection')? tableOperation+=TableOperations tableOperation+=TableOperations*)
	 * </pre>
	 */
	protected void sequence_CombinationOperations(ISerializationContext context, CombinationOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CsvType returns CsvType
	 *     InputType returns CsvType
	 *
	 * Constraint:
	 *     {CsvType}
	 * </pre>
	 */
	protected void sequence_CsvType(ISerializationContext context, CsvType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Export returns Export
	 *
	 * Constraint:
	 *     (table=ID path=STRING output=OutputType)
	 * </pre>
	 */
	protected void sequence_Export(ISerializationContext context, Export semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.EXPORT__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.EXPORT__TABLE));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.EXPORT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.EXPORT__PATH));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.EXPORT__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.EXPORT__OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportAccess().getTableIDTerminalRuleCall_1_0(), semanticObject.getTable());
		feeder.accept(grammarAccess.getExportAccess().getPathSTRINGTerminalRuleCall_3_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getExportAccess().getOutputOutputTypeParserRuleCall_5_0(), semanticObject.getOutput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldAverageTranformation returns FoldAverageTranformation
	 *
	 * Constraint:
	 *     {FoldAverageTranformation}
	 * </pre>
	 */
	protected void sequence_FoldAverageTranformation(ISerializationContext context, FoldAverageTranformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldSumTranformation returns FoldSumTranformation
	 *
	 * Constraint:
	 *     {FoldSumTranformation}
	 * </pre>
	 */
	protected void sequence_FoldSumTranformation(ISerializationContext context, FoldSumTranformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldTransformation returns FoldTransformation
	 *     Transformation returns FoldTransformation
	 *
	 * Constraint:
	 *     ((operation=FoldSumTranformation | operation=FoldAverageTranformation) groupBy=GroupBy?)
	 * </pre>
	 */
	protected void sequence_FoldTransformation(ISerializationContext context, FoldTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GetPathTransformation returns GetPathTransformation
	 *
	 * Constraint:
	 *     {GetPathTransformation}
	 * </pre>
	 */
	protected void sequence_GetPathTransformation(ISerializationContext context, GetPathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupBy returns GroupBy
	 *
	 * Constraint:
	 *     column=STRING
	 * </pre>
	 */
	protected void sequence_GroupBy(ISerializationContext context, GroupBy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.GROUP_BY__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.GROUP_BY__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupByAccess().getColumnSTRINGTerminalRuleCall_2_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HtmlType returns HtmlType
	 *
	 * Constraint:
	 *     cssPath=STRING?
	 * </pre>
	 */
	protected void sequence_HtmlType(ISerializationContext context, HtmlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InlinePipeline returns InlinePipeline
	 *
	 * Constraint:
	 *     pipelineExpr=Pipeline
	 * </pre>
	 */
	protected void sequence_InlinePipeline(ISerializationContext context, InlinePipeline semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.INLINE_PIPELINE__PIPELINE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.INLINE_PIPELINE__PIPELINE_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInlinePipelineAccess().getPipelineExprPipelineParserRuleCall_1_0(), semanticObject.getPipelineExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InlineSource returns InlineSource
	 *
	 * Constraint:
	 *     sourceExpr=Source
	 * </pre>
	 */
	protected void sequence_InlineSource(ISerializationContext context, InlineSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.INLINE_SOURCE__SOURCE_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.INLINE_SOURCE__SOURCE_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInlineSourceAccess().getSourceExprSourceParserRuleCall_1_0(), semanticObject.getSourceExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JsonType returns JsonType
	 *     InputType returns JsonType
	 *
	 * Constraint:
	 *     path=STRING?
	 * </pre>
	 */
	protected void sequence_JsonType(ISerializationContext context, JsonType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MetaData returns MetaData
	 *
	 * Constraint:
	 *     (metadata='filepath' | metadata='lastmodified')
	 * </pre>
	 */
	protected void sequence_MetaData(ISerializationContext context, MetaData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MyDsl returns MyDsl
	 *
	 * Constraint:
	 *     ((assignment+=Assignment+ export+=Export+) | export+=Export+)?
	 * </pre>
	 */
	protected void sequence_MyDsl(ISerializationContext context, MyDsl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputType returns OutputType
	 *
	 * Constraint:
	 *     (type=HtmlType | type=AutoType | type=CsvType)
	 * </pre>
	 */
	protected void sequence_OutputType(ISerializationContext context, OutputType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathTransformation returns PathTransformation
	 *     Transformation returns PathTransformation
	 *
	 * Constraint:
	 *     ((operation=AppendPathTransformation | operation=CanonicalizePathTransformation | operation=GetPathTransformation) column=STRING)
	 * </pre>
	 */
	protected void sequence_PathTransformation(ISerializationContext context, PathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PipelineTableOperation returns PipelineTableOperation
	 *
	 * Constraint:
	 *     (pipeline=SelectPipeline | pipeline=InlinePipeline)
	 * </pre>
	 */
	protected void sequence_PipelineTableOperation(ISerializationContext context, PipelineTableOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pipeline returns Pipeline
	 *
	 * Constraint:
	 *     (transformation+=Transformation transformation+=Transformation*)
	 * </pre>
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RemoveColumnTransformation returns RemoveColumnTransformation
	 *     ColumnTransformation returns RemoveColumnTransformation
	 *     Transformation returns RemoveColumnTransformation
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_RemoveColumnTransformation(ISerializationContext context, RemoveColumnTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RenameColumnTransformation returns RenameColumnTransformation
	 *     ColumnTransformation returns RenameColumnTransformation
	 *     Transformation returns RenameColumnTransformation
	 *
	 * Constraint:
	 *     (regex='regex'? from=STRING to=STRING)
	 * </pre>
	 */
	protected void sequence_RenameColumnTransformation(ISerializationContext context, RenameColumnTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoundCellsTransformation returns RoundCellsTransformation
	 *     CellTransformation returns RoundCellsTransformation
	 *     Transformation returns RoundCellsTransformation
	 *
	 * Constraint:
	 *     (columns+=STRING columns+=STRING* digits=INT)
	 * </pre>
	 */
	protected void sequence_RoundCellsTransformation(ISerializationContext context, RoundCellsTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectColumnTransformation returns SelectColumnTransformation
	 *     ColumnTransformation returns SelectColumnTransformation
	 *     Transformation returns SelectColumnTransformation
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_SelectColumnTransformation(ISerializationContext context, SelectColumnTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectPipeline returns SelectPipeline
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_SelectPipeline(ISerializationContext context, SelectPipeline semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SELECT_PIPELINE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SELECT_PIPELINE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectPipelineAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectRowsTransformation returns SelectRowsTransformation
	 *     RowTransformation returns SelectRowsTransformation
	 *     Transformation returns SelectRowsTransformation
	 *
	 * Constraint:
	 *     (start=INT length=INT? groupBy=STRING?)
	 * </pre>
	 */
	protected void sequence_SelectRowsTransformation(ISerializationContext context, SelectRowsTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectSource returns SelectSource
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_SelectSource(ISerializationContext context, SelectSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SELECT_SOURCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SELECT_SOURCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectSourceAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SetCellsTransformation returns SetCellsTransformation
	 *     CellTransformation returns SetCellsTransformation
	 *     Transformation returns SetCellsTransformation
	 *
	 * Constraint:
	 *     (value=STRING column=STRING row=STRING?)
	 * </pre>
	 */
	protected void sequence_SetCellsTransformation(ISerializationContext context, SetCellsTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SortRowsTransformation returns SortRowsTransformation
	 *     RowTransformation returns SortRowsTransformation
	 *     Transformation returns SortRowsTransformation
	 *
	 * Constraint:
	 *     (columns+=STRING columns+=STRING* (order='descending' | order='ascending')?)
	 * </pre>
	 */
	protected void sequence_SortRowsTransformation(ISerializationContext context, SortRowsTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceCoumnSelect returns SourceCoumnSelect
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_SourceCoumnSelect(ISerializationContext context, SourceCoumnSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceOperation returns SourceOperation
	 *
	 * Constraint:
	 *     (source=SelectSource | source=InlineSource)
	 * </pre>
	 */
	protected void sequence_SourceOperation(ISerializationContext context, SourceOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceStore returns SourceStore
	 *
	 * Constraint:
	 *     (metadata=MetaData column=STRING)
	 * </pre>
	 */
	protected void sequence_SourceStore(ISerializationContext context, SourceStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SOURCE_STORE__METADATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SOURCE_STORE__METADATA));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SOURCE_STORE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SOURCE_STORE__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceStoreAccess().getMetadataMetaDataParserRuleCall_1_0(), semanticObject.getMetadata());
		feeder.accept(grammarAccess.getSourceStoreAccess().getColumnSTRINGTerminalRuleCall_3_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     (query=STRING? filePath=STRING inputType=InputType? store+=SourceStore* select=SourceCoumnSelect?)
	 * </pre>
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableOperations returns TableOperations
	 *
	 * Constraint:
	 *     ((operation=SourceOperation | operation=CombinationOperations) transformations+=TransformOperation*)
	 * </pre>
	 */
	protected void sequence_TableOperations(ISerializationContext context, TableOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     operation=TableOperations
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TABLE__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TABLE__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAccess().getOperationTableOperationsParserRuleCall_0_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransformOperation returns TransformOperation
	 *
	 * Constraint:
	 *     (operation+=TransformationTableOperation | operation+=PipelineTableOperation)
	 * </pre>
	 */
	protected void sequence_TransformOperation(ISerializationContext context, TransformOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransformationTableOperation returns TransformationTableOperation
	 *
	 * Constraint:
	 *     transformation=Transformation
	 * </pre>
	 */
	protected void sequence_TransformationTableOperation(ISerializationContext context, TransformationTableOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TRANSFORMATION_TABLE_OPERATION__TRANSFORMATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TRANSFORMATION_TABLE_OPERATION__TRANSFORMATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransformationTableOperationAccess().getTransformationTransformationParserRuleCall_1_0(), semanticObject.getTransformation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     XmlType returns XmlType
	 *     InputType returns XmlType
	 *
	 * Constraint:
	 *     path=STRING?
	 * </pre>
	 */
	protected void sequence_XmlType(ISerializationContext context, XmlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     YamlType returns YamlType
	 *     InputType returns YamlType
	 *
	 * Constraint:
	 *     {YamlType}
	 * </pre>
	 */
	protected void sequence_YamlType(ISerializationContext context, YamlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
