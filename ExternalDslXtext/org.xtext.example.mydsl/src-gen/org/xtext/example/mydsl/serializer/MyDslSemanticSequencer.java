/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AddColumnTransformation;
import org.xtext.example.mydsl.myDsl.AppendPathTransformation;
import org.xtext.example.mydsl.myDsl.AutoType;
import org.xtext.example.mydsl.myDsl.CanonicalizePathTransformation;
import org.xtext.example.mydsl.myDsl.CombinationOperations;
import org.xtext.example.mydsl.myDsl.CsvType;
import org.xtext.example.mydsl.myDsl.Export;
import org.xtext.example.mydsl.myDsl.FoldAverageTranformation;
import org.xtext.example.mydsl.myDsl.FoldMaxTranformation;
import org.xtext.example.mydsl.myDsl.FoldSumTranformation;
import org.xtext.example.mydsl.myDsl.FoldTransformation;
import org.xtext.example.mydsl.myDsl.GetPathTransformation;
import org.xtext.example.mydsl.myDsl.GroupBy;
import org.xtext.example.mydsl.myDsl.HtmlType;
import org.xtext.example.mydsl.myDsl.JsonType;
import org.xtext.example.mydsl.myDsl.MetaData;
import org.xtext.example.mydsl.myDsl.MyDsl;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.OutputType;
import org.xtext.example.mydsl.myDsl.PathTransformation;
import org.xtext.example.mydsl.myDsl.Pipeline;
import org.xtext.example.mydsl.myDsl.PipelineTableOperation;
import org.xtext.example.mydsl.myDsl.RemoveColumnTransformation;
import org.xtext.example.mydsl.myDsl.RenameColumnTransformation;
import org.xtext.example.mydsl.myDsl.SelectColumnTransformation;
import org.xtext.example.mydsl.myDsl.Source;
import org.xtext.example.mydsl.myDsl.SourceCoumnSelect;
import org.xtext.example.mydsl.myDsl.SourceOperation;
import org.xtext.example.mydsl.myDsl.SourceStore;
import org.xtext.example.mydsl.myDsl.Table;
import org.xtext.example.mydsl.myDsl.TransformOperation;
import org.xtext.example.mydsl.myDsl.TransformationTableOperation;
import org.xtext.example.mydsl.myDsl.XmlType;
import org.xtext.example.mydsl.myDsl.YamlType;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ADD_COLUMN_TRANSFORMATION:
				sequence_AddColumnTransformation(context, (AddColumnTransformation) semanticObject); 
				return; 
			case MyDslPackage.APPEND_PATH_TRANSFORMATION:
				sequence_AppendPathTransformation(context, (AppendPathTransformation) semanticObject); 
				return; 
			case MyDslPackage.AUTO_TYPE:
				sequence_AutoType(context, (AutoType) semanticObject); 
				return; 
			case MyDslPackage.CANONICALIZE_PATH_TRANSFORMATION:
				sequence_CanonicalizePathTransformation(context, (CanonicalizePathTransformation) semanticObject); 
				return; 
			case MyDslPackage.COMBINATION_OPERATIONS:
				sequence_CombinationOperations(context, (CombinationOperations) semanticObject); 
				return; 
			case MyDslPackage.CSV_TYPE:
				sequence_CsvType(context, (CsvType) semanticObject); 
				return; 
			case MyDslPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case MyDslPackage.FOLD_AVERAGE_TRANFORMATION:
				sequence_FoldAverageTranformation(context, (FoldAverageTranformation) semanticObject); 
				return; 
			case MyDslPackage.FOLD_MAX_TRANFORMATION:
				sequence_FoldMaxTranformation(context, (FoldMaxTranformation) semanticObject); 
				return; 
			case MyDslPackage.FOLD_SUM_TRANFORMATION:
				sequence_FoldSumTranformation(context, (FoldSumTranformation) semanticObject); 
				return; 
			case MyDslPackage.FOLD_TRANSFORMATION:
				sequence_FoldTransformation(context, (FoldTransformation) semanticObject); 
				return; 
			case MyDslPackage.GET_PATH_TRANSFORMATION:
				sequence_GetPathTransformation(context, (GetPathTransformation) semanticObject); 
				return; 
			case MyDslPackage.GROUP_BY:
				sequence_GroupBy(context, (GroupBy) semanticObject); 
				return; 
			case MyDslPackage.HTML_TYPE:
				sequence_HtmlType(context, (HtmlType) semanticObject); 
				return; 
			case MyDslPackage.JSON_TYPE:
				sequence_JsonType(context, (JsonType) semanticObject); 
				return; 
			case MyDslPackage.META_DATA:
				sequence_MetaData(context, (MetaData) semanticObject); 
				return; 
			case MyDslPackage.MY_DSL:
				sequence_MyDsl(context, (MyDsl) semanticObject); 
				return; 
			case MyDslPackage.OUTPUT_TYPE:
				sequence_OutputType(context, (OutputType) semanticObject); 
				return; 
			case MyDslPackage.PATH_TRANSFORMATION:
				sequence_PathTransformation(context, (PathTransformation) semanticObject); 
				return; 
			case MyDslPackage.PIPELINE:
				sequence_Pipeline(context, (Pipeline) semanticObject); 
				return; 
			case MyDslPackage.PIPELINE_TABLE_OPERATION:
				sequence_PipelineTableOperation(context, (PipelineTableOperation) semanticObject); 
				return; 
			case MyDslPackage.REMOVE_COLUMN_TRANSFORMATION:
				sequence_RemoveColumnTransformation(context, (RemoveColumnTransformation) semanticObject); 
				return; 
			case MyDslPackage.RENAME_COLUMN_TRANSFORMATION:
				sequence_RenameColumnTransformation(context, (RenameColumnTransformation) semanticObject); 
				return; 
			case MyDslPackage.SELECT_COLUMN_TRANSFORMATION:
				sequence_SelectColumnTransformation(context, (SelectColumnTransformation) semanticObject); 
				return; 
			case MyDslPackage.SOURCE:
				sequence_Source(context, (Source) semanticObject); 
				return; 
			case MyDslPackage.SOURCE_COUMN_SELECT:
				sequence_SourceCoumnSelect(context, (SourceCoumnSelect) semanticObject); 
				return; 
			case MyDslPackage.SOURCE_OPERATION:
				sequence_SourceOperation(context, (SourceOperation) semanticObject); 
				return; 
			case MyDslPackage.SOURCE_STORE:
				sequence_SourceStore(context, (SourceStore) semanticObject); 
				return; 
			case MyDslPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case MyDslPackage.TRANSFORM_OPERATION:
				sequence_TransformOperation(context, (TransformOperation) semanticObject); 
				return; 
			case MyDslPackage.TRANSFORMATION_TABLE_OPERATION:
				sequence_TransformationTableOperation(context, (TransformationTableOperation) semanticObject); 
				return; 
			case MyDslPackage.XML_TYPE:
				sequence_XmlType(context, (XmlType) semanticObject); 
				return; 
			case MyDslPackage.YAML_TYPE:
				sequence_YamlType(context, (YamlType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AddColumnTransformation returns AddColumnTransformation
	 *     ColumnTransformation returns AddColumnTransformation
	 *     Transformation returns AddColumnTransformation
	 *
	 * Constraint:
	 *     (column=STRING value=STRING)
	 * </pre>
	 */
	protected void sequence_AddColumnTransformation(ISerializationContext context, AddColumnTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD_COLUMN_TRANSFORMATION__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD_COLUMN_TRANSFORMATION__COLUMN));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ADD_COLUMN_TRANSFORMATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ADD_COLUMN_TRANSFORMATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddColumnTransformationAccess().getColumnSTRINGTerminalRuleCall_1_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getAddColumnTransformationAccess().getValueSTRINGTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AppendPathTransformation returns AppendPathTransformation
	 *
	 * Constraint:
	 *     path=STRING
	 * </pre>
	 */
	protected void sequence_AppendPathTransformation(ISerializationContext context, AppendPathTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.APPEND_PATH_TRANSFORMATION__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.APPEND_PATH_TRANSFORMATION__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAppendPathTransformationAccess().getPathSTRINGTerminalRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AutoType returns AutoType
	 *     InputType returns AutoType
	 *
	 * Constraint:
	 *     {AutoType}
	 * </pre>
	 */
	protected void sequence_AutoType(ISerializationContext context, AutoType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CanonicalizePathTransformation returns CanonicalizePathTransformation
	 *
	 * Constraint:
	 *     {CanonicalizePathTransformation}
	 * </pre>
	 */
	protected void sequence_CanonicalizePathTransformation(ISerializationContext context, CanonicalizePathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CombinationOperations returns CombinationOperations
	 *     TableOperations returns CombinationOperations
	 *
	 * Constraint:
	 *     ((operation='merge' | operation='append') (type='union' | type='intersection')? tableOperation+=TableOperations tableOperation+=TableOperations*)
	 * </pre>
	 */
	protected void sequence_CombinationOperations(ISerializationContext context, CombinationOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CsvType returns CsvType
	 *     InputType returns CsvType
	 *
	 * Constraint:
	 *     {CsvType}
	 * </pre>
	 */
	protected void sequence_CsvType(ISerializationContext context, CsvType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Export returns Export
	 *
	 * Constraint:
	 *     (table=ID path=STRING output=OutputType)
	 * </pre>
	 */
	protected void sequence_Export(ISerializationContext context, Export semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPORT__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPORT__TABLE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPORT__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPORT__PATH));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPORT__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPORT__OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportAccess().getTableIDTerminalRuleCall_1_0(), semanticObject.getTable());
		feeder.accept(grammarAccess.getExportAccess().getPathSTRINGTerminalRuleCall_3_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getExportAccess().getOutputOutputTypeParserRuleCall_5_0(), semanticObject.getOutput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldAverageTranformation returns FoldAverageTranformation
	 *
	 * Constraint:
	 *     {FoldAverageTranformation}
	 * </pre>
	 */
	protected void sequence_FoldAverageTranformation(ISerializationContext context, FoldAverageTranformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldMaxTranformation returns FoldMaxTranformation
	 *
	 * Constraint:
	 *     column=STRING
	 * </pre>
	 */
	protected void sequence_FoldMaxTranformation(ISerializationContext context, FoldMaxTranformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOLD_MAX_TRANFORMATION__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOLD_MAX_TRANFORMATION__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFoldMaxTranformationAccess().getColumnSTRINGTerminalRuleCall_1_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldSumTranformation returns FoldSumTranformation
	 *
	 * Constraint:
	 *     {FoldSumTranformation}
	 * </pre>
	 */
	protected void sequence_FoldSumTranformation(ISerializationContext context, FoldSumTranformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FoldTransformation returns FoldTransformation
	 *     Transformation returns FoldTransformation
	 *
	 * Constraint:
	 *     ((operation=FoldMaxTranformation | operation=FoldSumTranformation | operation=FoldAverageTranformation) groupBy=GroupBy?)
	 * </pre>
	 */
	protected void sequence_FoldTransformation(ISerializationContext context, FoldTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GetPathTransformation returns GetPathTransformation
	 *
	 * Constraint:
	 *     {GetPathTransformation}
	 * </pre>
	 */
	protected void sequence_GetPathTransformation(ISerializationContext context, GetPathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupBy returns GroupBy
	 *
	 * Constraint:
	 *     column=STRING
	 * </pre>
	 */
	protected void sequence_GroupBy(ISerializationContext context, GroupBy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GROUP_BY__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GROUP_BY__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupByAccess().getColumnSTRINGTerminalRuleCall_2_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HtmlType returns HtmlType
	 *
	 * Constraint:
	 *     cssPath=STRING?
	 * </pre>
	 */
	protected void sequence_HtmlType(ISerializationContext context, HtmlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JsonType returns JsonType
	 *     InputType returns JsonType
	 *
	 * Constraint:
	 *     path=STRING?
	 * </pre>
	 */
	protected void sequence_JsonType(ISerializationContext context, JsonType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MetaData returns MetaData
	 *
	 * Constraint:
	 *     (metadata='filepath' | metadata='lastmodified')
	 * </pre>
	 */
	protected void sequence_MetaData(ISerializationContext context, MetaData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MyDsl returns MyDsl
	 *
	 * Constraint:
	 *     (
	 *         (pipelines+=Pipeline+ ((sources+=Source+ export+=Export+) | export+=Export+)) | 
	 *         (((pipelines+=Pipeline+ sources+=Source+) | sources+=Source+)? tables+=Table+ export+=Export+) | 
	 *         (sources+=Source+ export+=Export+) | 
	 *         export+=Export+
	 *     )?
	 * </pre>
	 */
	protected void sequence_MyDsl(ISerializationContext context, MyDsl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputType returns OutputType
	 *
	 * Constraint:
	 *     (type=HtmlType | type=AutoType | type=CsvType)
	 * </pre>
	 */
	protected void sequence_OutputType(ISerializationContext context, OutputType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PathTransformation returns PathTransformation
	 *     Transformation returns PathTransformation
	 *
	 * Constraint:
	 *     (column=STRING (operation=AppendPathTransformation | operation=CanonicalizePathTransformation | operation=GetPathTransformation))
	 * </pre>
	 */
	protected void sequence_PathTransformation(ISerializationContext context, PathTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PipelineTableOperation returns PipelineTableOperation
	 *
	 * Constraint:
	 *     pipeline=ID
	 * </pre>
	 */
	protected void sequence_PipelineTableOperation(ISerializationContext context, PipelineTableOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.PIPELINE_TABLE_OPERATION__PIPELINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.PIPELINE_TABLE_OPERATION__PIPELINE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPipelineTableOperationAccess().getPipelineIDTerminalRuleCall_0(), semanticObject.getPipeline());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pipeline returns Pipeline
	 *
	 * Constraint:
	 *     (name=ID transformation+=Transformation transformation+=Transformation*)
	 * </pre>
	 */
	protected void sequence_Pipeline(ISerializationContext context, Pipeline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RemoveColumnTransformation returns RemoveColumnTransformation
	 *     ColumnTransformation returns RemoveColumnTransformation
	 *     Transformation returns RemoveColumnTransformation
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_RemoveColumnTransformation(ISerializationContext context, RemoveColumnTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RenameColumnTransformation returns RenameColumnTransformation
	 *     ColumnTransformation returns RenameColumnTransformation
	 *     Transformation returns RenameColumnTransformation
	 *
	 * Constraint:
	 *     (from=STRING to=STRING)
	 * </pre>
	 */
	protected void sequence_RenameColumnTransformation(ISerializationContext context, RenameColumnTransformation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RENAME_COLUMN_TRANSFORMATION__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RENAME_COLUMN_TRANSFORMATION__FROM));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RENAME_COLUMN_TRANSFORMATION__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RENAME_COLUMN_TRANSFORMATION__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRenameColumnTransformationAccess().getFromSTRINGTerminalRuleCall_1_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getRenameColumnTransformationAccess().getToSTRINGTerminalRuleCall_3_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectColumnTransformation returns SelectColumnTransformation
	 *     ColumnTransformation returns SelectColumnTransformation
	 *     Transformation returns SelectColumnTransformation
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_SelectColumnTransformation(ISerializationContext context, SelectColumnTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceCoumnSelect returns SourceCoumnSelect
	 *
	 * Constraint:
	 *     (column+=STRING column+=STRING*)
	 * </pre>
	 */
	protected void sequence_SourceCoumnSelect(ISerializationContext context, SourceCoumnSelect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableOperations returns SourceOperation
	 *     SourceOperation returns SourceOperation
	 *
	 * Constraint:
	 *     source=ID
	 * </pre>
	 */
	protected void sequence_SourceOperation(ISerializationContext context, SourceOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SOURCE_OPERATION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SOURCE_OPERATION__SOURCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceOperationAccess().getSourceIDTerminalRuleCall_0(), semanticObject.getSource());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SourceStore returns SourceStore
	 *
	 * Constraint:
	 *     (metadata=MetaData column=STRING)
	 * </pre>
	 */
	protected void sequence_SourceStore(ISerializationContext context, SourceStore semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SOURCE_STORE__METADATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SOURCE_STORE__METADATA));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SOURCE_STORE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SOURCE_STORE__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceStoreAccess().getMetadataMetaDataParserRuleCall_1_0(), semanticObject.getMetadata());
		feeder.accept(grammarAccess.getSourceStoreAccess().getColumnSTRINGTerminalRuleCall_3_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Source returns Source
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         query=STRING? 
	 *         filePath=STRING 
	 *         inputType=InputType? 
	 *         store+=SourceStore* 
	 *         select=SourceCoumnSelect?
	 *     )
	 * </pre>
	 */
	protected void sequence_Source(ISerializationContext context, Source semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (name=ID operation=TableOperations)
	 * </pre>
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TABLE__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TABLE__OPERATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTableAccess().getOperationTableOperationsParserRuleCall_2_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TableOperations returns TransformOperation
	 *     TransformOperation returns TransformOperation
	 *
	 * Constraint:
	 *     (source=SourceOperation (operation+=TransformationTableOperation | operation+=PipelineTableOperation)+)
	 * </pre>
	 */
	protected void sequence_TransformOperation(ISerializationContext context, TransformOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TransformationTableOperation returns TransformationTableOperation
	 *
	 * Constraint:
	 *     transformation=Transformation
	 * </pre>
	 */
	protected void sequence_TransformationTableOperation(ISerializationContext context, TransformationTableOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRANSFORMATION_TABLE_OPERATION__TRANSFORMATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRANSFORMATION_TABLE_OPERATION__TRANSFORMATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransformationTableOperationAccess().getTransformationTransformationParserRuleCall_1_0(), semanticObject.getTransformation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     XmlType returns XmlType
	 *     InputType returns XmlType
	 *
	 * Constraint:
	 *     path=STRING?
	 * </pre>
	 */
	protected void sequence_XmlType(ISerializationContext context, XmlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     YamlType returns YamlType
	 *     InputType returns YamlType
	 *
	 * Constraint:
	 *     {YamlType}
	 * </pre>
	 */
	protected void sequence_YamlType(ISerializationContext context, YamlType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
